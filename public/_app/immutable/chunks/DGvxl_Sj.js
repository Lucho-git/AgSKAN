var l=63710088e-1,G={centimeters:l*100,centimetres:l*100,degrees:360/(2*Math.PI),feet:l*3.28084,inches:l*39.37,kilometers:l/1e3,kilometres:l/1e3,meters:l,metres:l,miles:l/1609.344,millimeters:l*1e3,millimetres:l*1e3,nauticalmiles:l/1852,radians:1,yards:l*1.0936};function E(e,i,t={}){const r={type:"Feature"};return(t.id===0||t.id)&&(r.id=t.id),t.bbox&&(r.bbox=t.bbox),r.properties=i||{},r.geometry=e,r}function B(e,i,t={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!d(e[0])||!d(e[1]))throw new Error("coordinates must contain numbers");return E({type:"Point",coordinates:e},i,t)}function D(e,i,t={}){for(const n of e){if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(n[n.length-1].length!==n[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<n[n.length-1].length;o++)if(n[n.length-1][o]!==n[0][o])throw new Error("First and last Position are not equivalent.")}return E({type:"Polygon",coordinates:e},i,t)}function O(e,i={}){const t={type:"FeatureCollection"};return i.id&&(t.id=i.id),i.bbox&&(t.bbox=i.bbox),t.features=e,t}function U(e,i,t={}){return E({type:"MultiPolygon",coordinates:e},i,t)}function X(e,i="kilometers"){const t=G[i];if(!t)throw new Error(i+" units is invalid");return e*t}function V(e){return e%360*Math.PI/180}function d(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}function S(e,i,t){if(e!==null)for(var r,n,o,s,f,a,u,g=0,c=0,y,m=e.type,p=m==="FeatureCollection",v=m==="Feature",A=p?e.features.length:1,w=0;w<A;w++){u=p?e.features[w].geometry:v?e.geometry:e,y=u?u.type==="GeometryCollection":!1,f=y?u.geometries.length:1;for(var M=0;M<f;M++){var h=0,b=0;if(s=y?u.geometries[M]:u,s!==null){a=s.coordinates;var P=s.type;switch(g=0,P){case null:break;case"Point":if(i(a,c,w,h,b)===!1)return!1;c++,h++;break;case"LineString":case"MultiPoint":for(r=0;r<a.length;r++){if(i(a[r],c,w,h,b)===!1)return!1;c++,P==="MultiPoint"&&h++}P==="LineString"&&h++;break;case"Polygon":case"MultiLineString":for(r=0;r<a.length;r++){for(n=0;n<a[r].length-g;n++){if(i(a[r][n],c,w,h,b)===!1)return!1;c++}P==="MultiLineString"&&h++,P==="Polygon"&&b++}P==="Polygon"&&h++;break;case"MultiPolygon":for(r=0;r<a.length;r++){for(b=0,n=0;n<a[r].length;n++){for(o=0;o<a[r][n].length-g;o++){if(i(a[r][n][o],c,w,h,b)===!1)return!1;c++}b++}h++}break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(S(s.geometries[r],i)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function W(e,i){if(e.type==="Feature")i(e,0);else if(e.type==="FeatureCollection")for(var t=0;t<e.features.length&&i(e.features[t],t)!==!1;t++);}function F(e,i){var t,r,n,o,s,f,a,u,g,c,y=0,m=e.type==="FeatureCollection",p=e.type==="Feature",v=m?e.features.length:1;for(t=0;t<v;t++){for(f=m?e.features[t].geometry:p?e.geometry:e,u=m?e.features[t].properties:p?e.properties:{},g=m?e.features[t].bbox:p?e.bbox:void 0,c=m?e.features[t].id:p?e.id:void 0,a=f?f.type==="GeometryCollection":!1,s=a?f.geometries.length:1,n=0;n<s;n++){if(o=a?f.geometries[n]:f,o===null){if(i(null,y,u,g,c)===!1)return!1;continue}switch(o.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":{if(i(o,y,u,g,c)===!1)return!1;break}case"GeometryCollection":{for(r=0;r<o.geometries.length;r++)if(i(o.geometries[r],y,u,g,c)===!1)return!1;break}default:throw new Error("Unknown Geometry Type")}}y++}}function R(e,i,t){var r=t;return F(e,function(n,o,s,f,a){o===0&&t===void 0?r=n:r=i(r,n,o,s,f,a)}),r}function _(e){return R(e,(i,t)=>i+q(t),0)}function q(e){let i=0,t;switch(e.type){case"Polygon":return L(e.coordinates);case"MultiPolygon":for(t=0;t<e.coordinates.length;t++)i+=L(e.coordinates[t]);return i;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}function L(e){let i=0;if(e&&e.length>0){i+=Math.abs(k(e[0]));for(let t=1;t<e.length;t++)i-=Math.abs(k(e[t]))}return i}var N=l*l/2,C=Math.PI/180;function k(e){const i=e.length-1;if(i<=2)return 0;let t=0,r=0;for(;r<i;){const n=e[r],o=e[r+1===i?0:r+1],s=e[r+2>=i?(r+2)%i:r+2],f=n[0]*C,a=o[1]*C,u=s[0]*C;t+=(u-f)*Math.sin(a),r++}return t*N}var Y=_;export{O as a,E as b,S as c,V as d,D as e,W as f,_ as g,U as m,B as p,X as r,Y as t};
