import{s as g,r as u,v as m,m as _,u as E,o as y,p as $}from"./scheduler.0ff5556b.js";import{S as F,i as b,c as I,a as k,m as N,t as p,b as h,d as D}from"./index.e3d1f712.js";import{g as S,a as q}from"./spread.8a54911c.js";import{I as A}from"./Icon.c7f64379.js";import{s as i}from"./supabaseClient.998d708c.js";function M(n){let e;const s=n[2].default,o=_(s,n,n[3],null);return{c(){o&&o.c()},l(t){o&&o.l(t)},m(t,r){o&&o.m(t,r),e=!0},p(t,r){o&&o.p&&(!e||r&8)&&E(o,s,t,t[3],e?$(s,t[3],r,null):y(t[3]),null)},i(t){e||(p(o,t),e=!0)},o(t){h(o,t),e=!1},d(t){o&&o.d(t)}}}function j(n){let e,s;const o=[{name:"info"},n[1],{iconNode:n[0]}];let t={$$slots:{default:[M]},$$scope:{ctx:n}};for(let r=0;r<o.length;r+=1)t=u(t,o[r]);return e=new A({props:t}),{c(){I(e.$$.fragment)},l(r){k(e.$$.fragment,r)},m(r,a){N(e,r,a),s=!0},p(r,[a]){const c=a&3?S(o,[o[0],a&2&&q(r[1]),a&1&&{iconNode:r[0]}]):{};a&8&&(c.$$scope={dirty:a,ctx:r}),e.$set(c)},i(r){s||(p(e.$$.fragment,r),s=!0)},o(r){h(e.$$.fragment,r),s=!1},d(r){D(e,r)}}}function v(n,e,s){let{$$slots:o={},$$scope:t}=e;const r=[["circle",{cx:"12",cy:"12",r:"10"}],["path",{d:"M12 16v-4"}],["path",{d:"M12 8h.01"}]];return n.$$set=a=>{s(1,e=u(u({},e),m(a))),"$$scope"in a&&s(3,t=a.$$scope)},e=m(e),[r,e,o,t]}class P extends F{constructor(e){super(),b(this,e,v,j,g,{})}}const z=P,G={async uploadFields(n,e){var s;try{const{data:o}=await i.auth.getSession();if(!((s=o==null?void 0:o.session)!=null&&s.user))throw new Error("Not authenticated");const t=[],r=[];if(!n||!Array.isArray(e)||e.length===0)throw new Error("Invalid data format");for(const a of e){if(a.status!=="accepted"){r.push({name:a.name,reason:"Not accepted"});continue}const c={map_id:n,name:a.name,area:a.area,boundary:a.boundary,properties:a.properties};try{const{data:l,error:d}=await i.from("fields").insert([c]).select("*");d?d.code==="23505"?r.push({name:a.name,reason:"Duplicate field name"}):r.push({name:a.name,reason:d.message}):l&&l.length>0&&t.push(l[0])}catch{r.push({name:a.name,reason:"Unexpected error"})}}if(t.length===0&&r.length>0){let a="";if(r.length===1)a=`Paddock "${r[0].name}" was rejected: ${r[0].reason}`;else{const c=[...new Set(r.map(l=>l.reason))];a=`All ${r.length} paddocks were rejected. Reasons: ${c.join(", ")}`}throw new Error(a)}return{success:!0,insertedFields:t,rejectedFields:r}}catch(o){return console.error("Error uploading fields:",o),{success:!1,message:o.message,insertedFields:[],rejectedFields:[]}}},async downloadFile(n){var e;try{const{data:s}=await i.auth.getSession();if(!((e=s==null?void 0:s.session)!=null&&e.user))throw new Error("Not authenticated");const t=`user_${s.session.user.id}/${n}`,{data:r,error:a}=await i.storage.from("user_files_bucket").download(t);if(a)throw new Error(`Failed to download file: ${a.message}`);if(!r)throw new Error("File not found");return{success:!0,data:r}}catch(s){return console.error("Error downloading file:",s),{success:!1,message:s.message}}},async deleteFile(n){var e;try{const{data:s}=await i.auth.getSession();if(!((e=s==null?void 0:s.session)!=null&&e.user))throw new Error("Not authenticated");const o=s.session.user.id,t=`user_${o}/${n}`,{data:r,error:a}=await i.storage.from("user_files_bucket").list(`user_${o}`,{limit:1,offset:0,search:n});if(a)throw a;if(!r||r.length===0)throw new Error("File not found in storage");const{error:c}=await i.storage.from("user_files_bucket").remove([t]);if(c)throw c;const{error:l}=await i.from("user_files").delete().match({file_name:n,user_id:o});if(l)throw l;return{success:!0,message:"File deleted successfully"}}catch(s){return console.error("Error deleting file:",s),{success:!1,message:s.message||"Error deleting file. If this persists please contact us."}}},async updateField(n,e,s){var o;try{const{data:t}=await i.auth.getSession();if(!((o=t==null?void 0:t.session)!=null&&o.user))throw new Error("Not authenticated");const r=t.session.user.id,{data:a,error:c}=await i.from("profiles").select("master_map_id").eq("id",r).single();if(c)throw new Error(`Profile error: ${c.message}`);const l=a.master_map_id;if(!l)throw new Error("No master map associated with user");const d={name:e};s!==void 0&&(d.area=s);const{data:w,error:f}=await i.from("fields").update(d).eq("field_id",n).eq("map_id",l).select();if(f)throw new Error(`Update error: ${f.message}`);return{success:!0,message:"Field updated successfully",data:w}}catch(t){return console.error("Error updating field:",t),{success:!1,message:t.message||"An error occurred while updating the field"}}},async deleteField(n){var e;try{const{data:s}=await i.auth.getSession();if(!((e=s==null?void 0:s.session)!=null&&e.user))throw new Error("Not authenticated");const o=s.session.user.id,{data:t,error:r}=await i.from("profiles").select("master_map_id").eq("id",o).single();if(r)throw new Error(`Profile error: ${r.message}`);const a=t.master_map_id;if(!a)throw new Error("No master map associated with user");const{error:c}=await i.from("fields").delete().eq("field_id",n).eq("map_id",a);if(c)throw new Error(`Delete error: ${c.message}`);return{success:!0,message:"Field deleted successfully"}}catch(s){return console.error("Error deleting field:",s),{success:!1,message:s.message||"An error occurred while deleting the field"}}},async uploadFile(n){var e;try{const{data:s}=await i.auth.getSession();if(!((e=s==null?void 0:s.session)!=null&&e.user))throw new Error("Not authenticated");const o=s.session.user.id;if(!n)throw new Error("No file selected");const{data:t,error:r}=await i.storage.from("user_files_bucket").upload(`user_${o}/${n.name}`,n);if(r)throw r;try{console.log("Attempting to upload to backup bucket...");const{data:l,error:d}=await i.storage.from("user_files_bucket_copy").upload(`user_${o}/${n.name}`,n);d?(console.error("Backup upload error:",d),console.log("Main upload succeeded, but backup failed. Check bucket permissions.")):console.log("Backup upload succeeded:",l)}catch(l){console.error("Exception during backup upload:",l),console.log("Continuing with main workflow despite backup failure")}const{data:a,error:c}=await i.from("user_files").insert({file_name:n.name,file_path:t.path,user_id:o}).select("*").single();if(c)throw c;return{success:!0,message:"File uploaded successfully",file:a}}catch(s){return console.error("Error uploading file:",s),{success:!1,message:s.message||"Failed to upload file"}}},async getUserFiles(){var n;try{const{data:e}=await i.auth.getSession();if(!((n=e==null?void 0:e.session)!=null&&n.user))throw new Error("Not authenticated");const s=e.session.user.id,{data:o,error:t}=await i.from("user_files").select("file_id, user_id, file_name, file_path, created_at").eq("user_id",s).order("created_at",{ascending:!1});if(t)throw t;return o.map(a=>({id:a.file_id,name:a.file_name,path:a.file_path,uploadedDate:a.created_at,status:"Processed",message:"File uploaded successfully"}))}catch(e){throw console.error("Error fetching user files:",e),new Error("Failed to fetch user files")}},async loadFields(){var n;try{const{data:e}=await i.auth.getSession();if(!((n=e==null?void 0:e.session)!=null&&n.user))throw new Error("Not authenticated");const s=e.session.user.id,{data:o,error:t}=await i.from("profiles").select("master_map_id").eq("id",s).single();if(t)throw t;const r=o.master_map_id;if(!r)throw new Error("No master map associated with user");const{data:a,error:c}=await i.from("fields").select("*").eq("map_id",r).order("name",{ascending:!0});if(c)throw c;return{fields:a}}catch(e){return console.error("Error loading fields:",e),{fields:[],error:e.message}}}};export{z as I,G as f};
